<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Radio Play Simulator</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    <!-- NETWORK DEPENDENCIES -->
    <script src="config.js?v=debug3"></script>
    <script src="js/paho-mqtt-min.js?v=debug3"></script>
    <script src="js/shared.js?v=debug4"></script>
    <script src="js/sequencer.js"></script>
    <style>
        body {
            background-color: #111;
            color: #eee;
            font-family: 'JetBrains Mono', monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 20px;
        }

        h1 {
            text-shadow: 0 0 10px #fff;
            margin-bottom: 20px;
        }

        #stage {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
            width: 100%;
            max-width: 1000px;
        }

        .box-container {
            flex: 1;
            background: #222;
            border: 2px solid #333;
            border-radius: 10px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
            transition: border-color 0.2s;
        }

        .box-container.active {
            border-color: #fff;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.2);
            background: #2a2a2a;
        }

        .box-title {
            font-weight: bold;
            font-size: 1.2em;
            margin-bottom: 5px;
        }

        .box-char {
            color: #888;
            font-size: 0.9em;
            margin-bottom: 15px;
        }

        .led-grid {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 5px;
            width: 100%;
        }

        .led {
            width: 12px;
            height: 12px;
            background-color: #111;
            border-radius: 50%;
            box-shadow: inset 0 0 2px #000;
            transition: background-color 0.05s, box-shadow 0.05s;
        }

        #controls {
            margin-top: 30px;
            display: flex;
            gap: 10px;
        }

        button {
            padding: 10px 30px;
            font-family: inherit;
            font-size: 16px;
            cursor: pointer;
            background: #333;
            color: #fff;
            border: 1px solid #555;
            border-radius: 5px;
        }

        button:hover {
            background: #444;
        }

        button.primary {
            background: #2fab34;
            border-color: #2fab34;
            color: #000;
            font-weight: bold;
        }

        #log {
            margin-top: 20px;
            width: 80%;
            height: 150px;
            background: #000;
            border: 1px solid #333;
            padding: 10px;
            overflow-y: auto;
            font-size: 12px;
            color: #0f0;
        }
    </style>
</head>

<body>

    <h1>Radio Play Simulator & Director</h1>

    <div id="controls">
        <button class="primary" style="background:#2fab34; border-color:#2fab34" onclick="startIntro()">â–¶ START RADIO
            PLAY</button>
        <button onclick="stopPlay()">STOP</button>
        <br><br>
        <strong>Generator Tests:</strong>
        <button onclick="testGeneratorIntro()" style="background:#ff6600; border-color:#ff6600">ðŸ”Š Intro (10s)</button>
        <button onclick="testGeneratorLoop()" style="background:#9933ff; border-color:#9933ff">ðŸ”Š Loop (22s)</button>
        <button onclick="testGeneratorLoop110()" style="background:#00cc99; border-color:#00cc99">ðŸ”Š Loop 110s
            (Full)</button>
        <button onclick="testKristineMix()" style="background:#ff3399; border-color:#ff3399">ðŸ”Š Kristine + Loop</button>
    </div>

    <!-- BOX 1: SAM -->
    <div class="box-container" id="box-sam">
        <div class="box-title">BOX 1 (Sam)</div>
        <div class="box-char">"SAM"</div>
        <div class="led-grid" id="leds-sam"></div>
    </div>

    <!-- BOX 2: KRISTINE -->
    <div class="box-container" id="box-kristine">
        <div class="box-title">BOX 2 (Kristine)</div>
        <div class="box-char">"KRISTINE"</div>
        <div class="led-grid" id="leds-kristine"></div>
    </div>

    <!-- BOX 3: JACOB -->
    <div class="box-container" id="box-jacob">
        <div class="box-title">BOX 3 (Jacob)</div>
        <div class="box-char">"JACOB"</div>
        <div class="led-grid" id="leds-jacob"></div>
    </div>
    </div>

    <div id="log"></div>

    <script>
        // --- CONFIG ---
        // We moved audio to "www/audio", so relative path "audio/" should work for index.html in "www/"
        // BUT simulator.html is in "www/", so "audio/" refers to "www/audio/". This is correct.

        const LEDS_PER_BOX = 60;

        const SCRIPT = [
            // Round 1
            { char: 'pip', file: 'Pip 1.mp3' },
            { char: 'bram', file: 'Bram 1.mp3' },
            { char: 'tink', file: 'Tink 1.mp3' },
            // Round 2
            { char: 'pip', file: 'Pip 2.mp3' },
            { char: 'bram', file: 'Bram 2.mp3' },
            { char: 'tink', file: 'Tink 2.mp3' },
            // Round 3
            { char: 'pip', file: 'Pip 3.mp3' },
            { char: 'bram', file: 'Bram 3.mp3' },
            { char: 'tink', file: 'Tink 3.mp3' },
            // Round 4
            { char: 'pip', file: 'Pip 4.mp3' },
            { char: 'bram', file: 'Bram 4.mp3' },
            { char: 'tink', file: 'Tink 4.mp3' },
            // Round 5
            { char: 'pip', file: 'Pip 5.mp3' },
            { char: 'bram', file: 'Bram 5.mp3' },
            { char: 'tink', file: 'Tink 5.mp3' },
            // Round 6 (Bram out)
            { char: 'pip', file: 'Pip 6.mp3' },
            { char: 'tink', file: 'Tink 6.mp3' },
        ];

        // --- SETUP ---
        const seq = new ScriptSequencer();

        // INIT NETWORK
        if (window.Network) {
            console.log("Initializing Director Network...");
            Network.init();
        }

        const BOX_MAP = {
            'sam': 'sam',
            'kristine': 'kristine',
            'jacob': 'jacob'
        };

        const ledElements = { sam: [], kristine: [], jacob: [] };

        ['sam', 'kristine', 'jacob'].forEach(id => {
            const container = document.getElementById(`leds-${id}`);
            for (let i = 0; i < LEDS_PER_BOX; i++) {
                const led = document.createElement('div');
                led.className = 'led';
                container.appendChild(led);
                ledElements[id].push(led);
            }
        });

        function log(msg) {
            const l = document.getElementById('log');
            l.innerHTML += `<div>[${new Date().toLocaleTimeString()}] ${msg}</div>`;
            l.scrollTop = l.scrollHeight;
        }

        // --- SEQUENCER HOOKS ---

        let activeBox = null;

        seq.on('onItemStart', (item) => {
            const boxId = BOX_MAP[item.character.toLowerCase()];
            log(`â–¶ï¸ START: ${item.character} (${item.file})`);

            document.querySelectorAll('.box-container').forEach(d => d.classList.remove('active'));
            const container = document.getElementById(`box-${boxId}`);
            if (container) container.classList.add('active');

            activeBox = boxId;

            // DIRECTOR MODE: Send MQTT Command
            if (window.Network && boxId) {
                // Assuming 'speaking' animation type 8 defined in firmware
                // We need to pass the simple 'name' that Network.sendAnim expects
                // But shared.js getBoxIndex searches by ID/Name. 
                // Let's pass the boxId ('tink'/'bram'/'pip') which hopefully maps to 'sam'/'kristine'/'jacob' via config or shared.js handling.
                // Wait, shared.js sendAnim uses getBoxIndex(name). 
                // Config.js likely has IDs: 'box_1_holiday' (Sam), 'box_2_holiday' (Kris), etc.
                // We need a mapping from Character -> Real Box Name for Network.js

                // TEMP MAPPING for Director:
                const CHAR_TO_REAL = {
                    'tink': 'sam',
                    'bram': 'kristine',
                    'pip': 'jacob'
                };
                const realName = CHAR_TO_REAL[item.character.toLowerCase()];
                if (realName) {
                    Network.sendAnim(realName, 'speaking', 'on');
                }
            }
        });

        seq.on('onItemEnd', (item) => {
            log(`â¹ï¸ END: ${item.character}`);
            activeBox = null;
            document.querySelectorAll('.box-container').forEach(d => d.classList.remove('active'));
            clearAllLeds();

            // DIRECTOR MODE: Stop MQTT Animation
            const CHAR_TO_REAL = {
                'tink': 'sam',
                'bram': 'kristine',
                'pip': 'jacob'
            };
            const realName = CHAR_TO_REAL[item.character.toLowerCase()];
            if (realName && window.Network) {
                Network.sendAnim(realName, 'speaking', 'off');
            }
        });

        seq.on('onComplete', () => {
            log("âœ… SHOW COMPLETE");
            activeBox = null;
            clearAllLeds();
        });

        // --- ANIMATION LOOP ---
        function animate() {
            if (activeBox) {
                const strip = ledElements[activeBox];
                if (strip) {
                    let amp = 0;

                    if (finaleInterval && finaleAnalyser) {
                        // Finale Mode
                        finaleAnalyser.getByteFrequencyData(finaleDataArray);
                        let sum = 0;
                        for (let i = 0; i < finaleDataArray.length; i++) {
                            sum += finaleDataArray[i];
                        }
                        amp = sum / finaleDataArray.length / 255;
                    } else {
                        // Original Mode
                        amp = seq.getAmplitude(); // 0.0 to 1.0 (approx)
                    }

                    const boostAmp = Math.min(1.0, amp * 5); // Boost signal
                    // console.log(boostAmp); // Debug

                    // Clear first
                    strip.forEach(l => {
                        l.style.backgroundColor = '#111';
                        l.style.boxShadow = 'none';
                    });

                    if (activeBox === 'sam') {
                        // BOX 1 (Sam): Random Flicker
                        const numActive = Math.floor(Math.random() * (strip.length / 2)) + 5;
                        for (let i = 0; i < numActive; i++) {
                            const idx = Math.floor(Math.random() * strip.length);
                            const r = 255;
                            const g = 180 + Math.floor(Math.random() * 50);
                            const b = 50 + Math.floor(Math.random() * 50);
                            const color = `rgb(${r},${g},${b})`;
                            strip[idx].style.backgroundColor = color;
                            strip[idx].style.boxShadow = `0 0 10px ${color}`;
                        }
                    } else if (activeBox === 'kristine') {
                        // BOX 2 (Kristine): Center Out
                        const center = Math.floor(strip.length / 2);
                        const width = Math.floor(boostAmp * (strip.length / 2));
                        const r = 255; const g = 200; const b = 100;

                        for (let i = 0; i <= width; i++) {
                            if (center - i >= 0) setLed(strip[center - i], r, g, b);
                            if (center + i < strip.length) setLed(strip[center + i], r, g, b);
                        }
                    } else if (activeBox === 'jacob') {
                        // BOX 3 (Jacob): Bottom Up
                        const count = Math.floor(boostAmp * strip.length);
                        const r = 255; const g = 100; const b = 50;

                        for (let i = 0; i < count; i++) {
                            setLed(strip[strip.length - 1 - i], r, g, b);
                        }
                    }
                }
            }
            requestAnimationFrame(animate);
        }

        function setLed(el, r, g, b) {
            if (!el) return;
            const color = `rgb(${r},${g},${b})`;
            el.style.backgroundColor = color;
            el.style.boxShadow = `0 0 10px ${color}`;
        }

        function clearAllLeds() {
            ['sam', 'kristine', 'jacob'].forEach(id => {
                ledElements[id].forEach(l => {
                    l.style.backgroundColor = '#111';
                    l.style.boxShadow = 'none';
                });
            });
        }

        animate();

        // --- CONTROLS ---

        function startPlay() {
            // Update to use relative path in 'audio/' folder
            /*
             - [x] Record/Generate audio files (split by line: `tink_01.mp3`, etc.).
             - [x] Upload audio assets to Web Server.
             - [ ] **Director Software (Web)**
             - [x] Create `ScriptSequencer` class.
             - [ ] Link `simulator.html` to MQTT (Director Mode).
             - [ ] Create Trigger Button in Admin.lative path in 'audio/' folder
            */
            // AND map 'char' to 'character' for sequencer
            const loadScript = SCRIPT.map(s => ({
                character: s.char,
                file: `audio/${s.file}`
            }));

            seq.loadScript(loadScript);
            seq.play();
        }

        function stopPlay() {
            seq.stop();
            if (finaleInterval) clearInterval(finaleInterval);
            ['sam', 'kris', 'jacob', 'tink', 'bram', 'pip'].forEach(id => {
                const audio = document.getElementById('aud-' + id);
                if (audio) { audio.pause(); audio.currentTime = 0; }
            });
            activeBox = null;
            clearAllLeds();

            // Send MQTT stop command to all boxes
            if (window.Network && window.Network.client && window.Network.client.isConnected()) {
                [0, 1, 2].forEach(boxIdx => {
                    Network.send('stop', {}, boxIdx);
                });
                log("â¹ï¸ STOP sent to all boxes");
            }
        }

        // --- FINALE LOGIC ---
        let finaleInterval = null;
        let finaleSequence = [];
        let finaleStartTime = 0;

        async function startIntro() {
            stopPlay();
            log("ðŸš€ STARTING RADIO PLAY (Distributed Audio)...");

            // 1. Load Sequence
            try {
                const res = await fetch('show_sequence.json');
                finaleSequence = await res.json();
                finaleSequence.forEach(e => e.fired = false); // Reset
            } catch (e) {
                log("âŒ Error loading sequence: " + e.message);
                log("âš ï¸ MUST RUN ON LOCALHOST (Python server), NOT file://");
                return;
            }

            // 2. Send SYNCHRONIZED BROADCAST Play command to ALL boxes
            //    All boxes subscribe to "lockbox/all/cmd" and will start simultaneously
            if (window.Network && window.Network.client && window.Network.client.isConnected()) {
                // Send single broadcast message - all boxes receive at same time
                const msgData = { action: 'play_intro' };
                const message = new Paho.MQTT.Message(JSON.stringify(msgData));
                message.destinationName = "lockbox/all/cmd";
                Network.client.send(message);
                log("ðŸ“¡ BROADCAST: All boxes starting synchronized playback!");
            } else {
                log("âš ï¸ MQTT not connected - audio will NOT play on boxes!");
            }

            log("â–¶ï¸ SHOW STARTED");
            finaleStartTime = Date.now();
            finaleInterval = setInterval(updateFinale, 50);
        }

        // --- GENERATOR TEST FUNCTIONS ---
        function testGeneratorIntro() {
            log("ðŸ”Š Testing Generator INTRO (first 10 seconds) on ALL boxes...");
            if (window.Network && window.Network.client && window.Network.client.isConnected()) {
                // Send play command to all boxes
                [0, 1, 2].forEach(boxIdx => {
                    Network.send('play', { file: 'generator_intro' }, boxIdx);
                });
                log("âœ… Sent generator_intro to all boxes");
            } else {
                log("âš ï¸ MQTT not connected!");
            }
        }

        function testGeneratorLoop() {
            log("ðŸ”Š Testing Generator LOOP (last 22 seconds) on ALL boxes...");
            if (window.Network && window.Network.client && window.Network.client.isConnected()) {
                // Send play command to all boxes
                [0, 1, 2].forEach(boxIdx => {
                    Network.send('play', { file: 'generator_loop' }, boxIdx);
                });
                log("âœ… Sent generator_loop to all boxes");
            } else {
                log("âš ï¸ MQTT not connected!");
            }
        }

        function testGeneratorLoop110() {
            log("ðŸ”Š Testing Generator LOOP 110s (full fade envelope) on ALL boxes...");
            if (window.Network && window.Network.client && window.Network.client.isConnected()) {
                // Send play command to all boxes
                [0, 1, 2].forEach(boxIdx => {
                    Network.send('play', { file: 'generator_loop_110s' }, boxIdx);
                });
                log("âœ… Sent generator_loop_110s to all boxes");
            } else {
                log("âš ï¸ MQTT not connected!");
            }
        }

        function testKristineMix() {
            log("ðŸ”Š Testing Kristine voice + generator loop on Box 2...");
            if (window.Network && window.Network.client && window.Network.client.isConnected()) {
                Network.send('play', { file: 'test_kristine_mix' }, 1); // Box 2 = index 1
                log("âœ… Sent test_kristine_mix to Box 2");
            } else {
                log("âš ï¸ MQTT not connected!");
            }
        }

        function createAudio(id, src) {
            const a = document.createElement('audio');
            a.id = 'aud-' + id;
            a.src = src;
            document.body.appendChild(a);
        }

        function updateFinale() {
            const elapsed = Date.now() - finaleStartTime;
            let allDone = true;

            finaleSequence.forEach(evt => {
                if (!evt.fired) {
                    allDone = false;
                    if (elapsed >= evt.time) {
                        evt.fired = true;

                        // Box names now match directly
                        const simId = evt.box.toLowerCase();

                        // Log
                        if (evt.state === 'on') {
                            log(`ðŸ’¡ ${evt.box.toUpperCase()} SPEAKING`);
                            activeBox = simId;

                            // Visuals (browser simulator)
                            document.querySelectorAll('.box-container').forEach(d => d.classList.remove('active'));
                            document.getElementById(`box-${simId}`).classList.add('active');

                            // MQTT: Tell physical box to show "speaking" LED pattern
                            if (window.Network && window.Network.client && window.Network.client.isConnected()) {
                                const boxIdx = Network.getBoxIndex(simId);
                                Network.send('pattern', { mode: 'sparkle' }, boxIdx);
                            }
                        } else {
                            // Only turn off if it matches current?
                            if (activeBox === simId) {
                                activeBox = null;
                                document.querySelectorAll('.box-container').forEach(d => d.classList.remove('active'));
                                clearAllLeds(); // Stop animation
                            }

                            // MQTT: Tell physical box to stop "speaking" (go to game/breathing pattern)
                            if (window.Network && window.Network.client && window.Network.client.isConnected()) {
                                const boxIdx = Network.getBoxIndex(simId);
                                Network.send('pattern', { mode: 'breathing' }, boxIdx);
                            }
                        }
                    }
                }
            });

            // Keep animating via the main loop 'animate()' which checks 'activeBox'

            if (allDone && elapsed > 105000) {
                log("âœ… FINALE COMPLETE");
                stopPlay();
            }
        }

    </script>
</body>

</html>
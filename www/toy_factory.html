<!DOCTYPE html>
<html>

<head>
    <title>NORTH POLE FACTORY</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="css/style.css">
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            background: url('background.png') no-repeat center center fixed;
            background-size: cover;
            height: 100vh;
            margin: 0;
            user-select: none;
            font-family: var(--font-body);
        }

        .game-ui {
            position: relative;
            width: 100%;
            height: 100%;
            display: grid;
            grid-template-rows: 1fr auto;
            pointer-events: none;
        }

        /* HUD - Top */
        .hud-top {
            display: flex;
            justify-content: flex-end;
            align-items: flex-start;
            /* Align to Right */
            padding: 20px;
            pointer-events: auto;
        }

        /* Target Display (Top Left) */
        .target-display {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.6);
            border: 4px solid #5d4037;
            border-radius: 10px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            pointer-events: auto;
        }

        .target-label {
            color: var(--gold);
            font-family: var(--font-title);
            font-size: 1.2em;
            margin-bottom: 5px;
        }

        .target-icon {
            width: 80px;
            height: 80px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }

        /* MAIN CONTROL DECK - Bottom */
        .control-deck {
            background: rgba(46, 38, 21, 0.9);
            border-top: 4px solid #5d4037;
            box-shadow: 0 -10px 30px rgba(0, 0, 0, 0.8);
            padding: 20px;
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            /* Spaced out */
            gap: 20px;
            pointer-events: auto;
            align-items: center;
            height: 110px;
            justify-items: center;
        }

        /* BUTTONS */
        .drop-btn {
            width: 120px;
            height: 120px;
            /* Overlap top slightly */
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #d32f2f, #b71c1c);
            border: 6px solid #5f0000;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.6);
            color: white;
            font-family: var(--font-title);
            font-size: 2em;
            font-weight: bold;
            cursor: pointer;
            text-shadow: 0 2px 2px rgba(0, 0, 0, 0.5);
            transition: transform 0.1s;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-top: -30px;
            /* Pop out */
        }

        .drop-btn:active {
            transform: scale(0.95);
            margin-top: -25px;
        }

        .drop-btn:disabled {
            filter: grayscale(1);
            cursor: not-allowed;
        }

        .arrow-btn {
            width: 100px;
            height: 70px;
            background: linear-gradient(to bottom, #4caf50, #2e7d32);
            border: none;
            cursor: pointer;
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.5);
            transition: transform 0.1s, filter 0.1s;
        }

        .arrow-left {
            clip-path: polygon(0 50%, 40% 0, 40% 30%, 100% 30%, 100% 70%, 40% 70%, 40% 100%);
        }

        .arrow-right {
            clip-path: polygon(60% 0, 100% 50%, 60% 100%, 60% 70%, 0 70%, 0 30%, 60% 30%);
        }

        .arrow-btn:active {
            transform: scale(0.95);
        }

        /* CANVAS */
        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }

        /* OVERLAYS */
        .feedback-overlay {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: var(--font-title);
            font-size: 5em;
            text-shadow: 0 0 20px black;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
            z-index: 20;
        }

        .feedback-success {
            color: var(--success);
        }

        .feedback-fail {
            color: var(--theme-red);
        }

        .win-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            /* Hidden by opacity usually, but we toggle class */
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 1s;
        }

        .win-screen.active {
            opacity: 1;
            pointer-events: auto;
        }

        .win-title {
            font-family: var(--font-title);
            color: var(--gold);
            font-size: 4em;
            text-shadow: 0 0 20px var(--gold);
            margin-bottom: 20px;
            text-align: center;
        }

        .win-btn {
            padding: 15px 40px;
            font-size: 2em;
            font-family: var(--font-title);
            background: var(--theme-red);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 0 20px var(--theme-red);
        }

        /* MUSIC TOGGLE */
        .music-toggle {
            cursor: pointer;
            color: var(--gold);
            border: 1px solid var(--gold);
            padding: 5px 15px;
            border-radius: 4px;
            font-family: var(--font-terminal);
            background: rgba(0, 0, 0, 0.5);
            pointer-events: auto;
        }
    </style>
</head>

<body>

    <audio id="bgMusic" src="Merry Merry Everywhere.mp3" loop></audio>
    <canvas id="gameCanvas"></canvas>

    <!-- Target HUD -->
    <div class="target-display">
        <div class="target-label">TARGET</div>
        <canvas id="targetCanvas" width="80" height="80"></canvas>
    </div>

    <!-- Win Screen -->
    <div class="win-screen" id="winScreen">
        <div class="win-title">QUOTA MET!<br><span style="font-size:0.5em">FACTORY SYNCED</span></div>
        <button class="win-btn" onclick="location.reload()">NEXT BATCH</button>
    </div>

    <div class="game-ui">
        <div class="hud-top">
            <div class="music-toggle" onclick="toggleMusic()">MUSIC: OFF</div>
        </div>
        <div style="flex-grow:1"></div>
        <div class="control-deck">
            <button class="arrow-btn arrow-left" id="btnLeft"></button>
            <button class="drop-btn" id="btnDrop" onclick="triggerDrop()">DROP</button>
            <button class="arrow-btn arrow-right" id="btnRight"></button>
        </div>
    </div>

    <div id="feedback" class="feedback-overlay">PERFECT!</div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const targetCtx = document.getElementById('targetCanvas').getContext('2d');

        let width, height;

        // --- ASSETS ---
        const ASSETS_PATH = 'assets/toy_factory/';
        // SPRITE_SIZE removed, using full images

        // Asset IDs
        const ASSETS = {
            'CLAW': 'claw.png',
            'TOYS': ['Car.png', 'Present.png', 'Robot.png', 'Teddy.png', 'Top.png', 'Train.png'],
            'TOOLS': ['Bolt.png', 'Cog.png', 'Hammer.png', 'Oil Can.png', 'Scrap.png', 'Wrench.png']
        };

        const TOY_KEYS = ['TOY_Car', 'TOY_Present', 'TOY_Robot', 'TOY_Teddy', 'TOY_Top', 'TOY_Train'];
        const TOOL_KEYS = ['TOOL_Bolt', 'TOOL_Cog', 'TOOL_Hammer', 'TOOL_Oil', 'TOOL_Scrap', 'TOOL_Wrench'];

        const images = {};
        let assetsLoaded = 0;
        const totalAssets = Object.keys(ASSETS).length;

        // --- GAME STATE ---
        const ITEM_SPACING = 300;
        let beltY = 0; // Set in resize
        let items = [];
        let beltOffset = 0;
        const BELT_SPEED = 2; // Constant speed
        let clawTargetSpeed = 0;

        // Claw Logic
        let claw = {
            state: 'IDLE', // IDLE, DOWN, GRAB_WAIT, UP
            y: 0,
            x: 0, // Centered
            holding: null, // Item object
            openPct: 1.0, // 1.0 = Open, 0.0 = Closed
            length: 0
        };
        const CLAW_SPEED = 8;
        const CLAW_IDLE_Y = 180; // Lower start pos (was 130)

        // Progression
        let toysCollected = 0;
        const TARGET_QUOTA = 5;
        let isGameOver = false;
        let targetType = 0; // Index 0-3 of toys

        // --- INIT ---
        function preloadAssets() {
            // Load Claw
            if (ASSETS['CLAW']) loadImage('CLAW', ASSETS['CLAW']);

            // Load Toys
            if (ASSETS['TOYS']) {
                ASSETS['TOYS'].forEach((file, i) => {
                    loadImage(TOY_KEYS[i], file);
                });
            }

            // Load Tools
            if (ASSETS['TOOLS']) {
                ASSETS['TOOLS'].forEach((file, i) => {
                    loadImage(TOOL_KEYS[i], file);
                });
            }

            // Music check
            if (window.EMBEDDED_ASSETS && window.EMBEDDED_ASSETS['MUSIC']) {
                document.getElementById('bgMusic').src = window.EMBEDDED_ASSETS['MUSIC'];
            }
        }

        function loadImage(key, src) {
            const img = new Image();
            if (window.EMBEDDED_ASSETS && window.EMBEDDED_ASSETS[key]) {
                img.src = window.EMBEDDED_ASSETS[key];
            } else {
                img.src = ASSETS_PATH + src;
            }
            img.onload = () => {
                assetsLoaded++;
                // Total assets: 1 claw + 6 toys + 6 tools = 13
                if (assetsLoaded === 13) init();
            };
            images[key] = img;
        }



        function init() {
            resize();
            claw.y = CLAW_IDLE_Y; // Force visible start
            // Init items
            for (let i = -5; i < 5; i++) {
                items.push(generateItem(i * ITEM_SPACING));
            }
            randomizeTarget();
            loop();
        }

        function generateItem(xFunc) {
            const isToy = Math.random() < 0.7;
            // 6 toys (0-5)
            let idx = Math.floor(Math.random() * 6);

            // Bias: Ensure target appears frequently (20% bonus chance if it's a toy)
            if (isToy && Math.random() < 0.2) {
                idx = targetType;
            }

            return {
                x: xFunc,
                isToy: isToy,
                idx: idx,
                uid: Math.random(),
                picked: false
            };
        }

        function randomizeTarget() {
            targetType = Math.floor(Math.random() * 6);
            drawTargetIcon();
        }

        function drawTargetIcon() {
            targetCtx.clearRect(0, 0, 80, 80);
            const key = TOY_KEYS[targetType];
            const img = images[key];
            if (img) {
                targetCtx.drawImage(img, 0, 0, img.width, img.height, 0, 0, 80, 80);
            }
        }

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;

            claw.x = width / 2;
            beltY = height / 2; // Exact center to match background
        }
        window.addEventListener('resize', resize);

        // --- CONTROLS ---
        const btnLeft = document.getElementById('btnLeft');
        const btnRight = document.getElementById('btnRight');

        const CLAW_MOVE_SPEED = 8;
        btnLeft.addEventListener('mousedown', () => clawTargetSpeed = -CLAW_MOVE_SPEED);
        btnLeft.addEventListener('mouseup', () => clawTargetSpeed = 0);
        btnLeft.addEventListener('mouseleave', () => clawTargetSpeed = 0);

        btnRight.addEventListener('mousedown', () => clawTargetSpeed = CLAW_MOVE_SPEED);
        btnRight.addEventListener('mouseup', () => clawTargetSpeed = 0);
        btnRight.addEventListener('mouseleave', () => clawTargetSpeed = 0);

        function triggerDrop() {
            if (claw.state === 'IDLE' && !isGameOver) {
                claw.state = 'DOWN';
                document.getElementById('btnDrop').disabled = true;
            }
        }

        // --- UPDATE ---
        function update() {
            if (isGameOver) return;

            // Belt Physics
            beltOffset += BELT_SPEED;

            // Claw Movement
            if (claw.state === 'IDLE') {
                claw.x += clawTargetSpeed;
                // Clamp
                if (claw.x < 50) claw.x = 50;
                if (claw.x > width - 50) claw.x = width - 50;
            }

            // Loop Items
            const totalW = items.length * ITEM_SPACING;
            items.forEach(i => {
                if (i.picked) return; // Don't loop if held
                let dist = i.x + beltOffset;
                // Simple wrapping logic can be tricky with absolute positions.
                // Let's just reset X relative to center
                // Normalized pos: i.x + beltOffset
                // If i.x + beltOffset > totalW/2 -> i.x -= totalW

                // Keep relative to camera seems harder. 
                // Let's just move items physically? No, keeps drifting.
                // Camera is wrapping. viewCenter = -beltOffset.

                let viewPos = i.x + beltOffset;
                while (viewPos > totalW / 2) {
                    i.x -= totalW;
                    viewPos -= totalW;
                    // Regenerate item to create infinite stream
                    const fresh = generateItem(i.x);
                    i.isToy = fresh.isToy;
                    i.idx = fresh.idx;
                    i.picked = false;
                }
                while (viewPos < -totalW / 2) {
                    i.x += totalW;
                    viewPos += totalW;
                    // Regenerate on reverse wrap too
                    const fresh = generateItem(i.x);
                    i.isToy = fresh.isToy;
                    i.idx = fresh.idx;
                    i.picked = false;
                }
            });

            // Claw Physics
            if (claw.state === 'DOWN') {
                claw.y += CLAW_SPEED;

                // Collision with Belt Level
                // Use global beltY
                if (claw.y >= beltY) {
                    claw.y = beltY;
                    attemptGrab();
                    claw.state = 'GRAB_WAIT';
                    setTimeout(() => claw.state = 'UP', 500);
                }
            } else if (claw.state === 'UP') {
                claw.y -= CLAW_SPEED;
                if (claw.y <= CLAW_IDLE_Y) {
                    claw.y = CLAW_IDLE_Y;
                    claw.state = 'IDLE';
                    processResult();
                }
            }

            // Clamp openPct
            if (claw.state === 'DOWN' || claw.state === 'IDLE') claw.openPct = 1.0;
            if (claw.state === 'GRAB_WAIT' || claw.state === 'UP') claw.openPct = 0.0; // Closing/Closed
        }

        function attemptGrab() {
            // Find closest item to center
            let closest = null;
            let minDist = 80; // Grab radius

            items.forEach(item => {
                if (item.picked) return;
                const screenX = width / 2 + item.x + beltOffset;
                // Item X is rel to center? No.
                // screenX calculation above mimics drawItem logic
                // Center of screen is width/2.
                // Item screen pos is correct. Claw X is width/2.
                const dist = Math.abs(screenX - claw.x);
                if (dist < minDist) {
                    closest = item;
                    minDist = dist;
                }
            });

            if (closest) {
                closest.picked = true;
                claw.holding = closest;
            }
        }

        function processResult() {
            document.getElementById('btnDrop').disabled = false;

            if (claw.holding) {
                const item = claw.holding;
                claw.holding = null;

                // Check match
                if (item.isToy && item.idx === targetType) {
                    // Success
                    toysCollected++;
                    showFeedback("MATCH!", true);
                    if (toysCollected >= TARGET_QUOTA) winGame();
                    else randomizeTarget();
                } else {
                    // Fail
                    showFeedback(item.isToy ? "WRONG TOY" : "UNKOWN ITEM", false);
                }

                // Recycle item
                item.picked = false;
                item.x = -beltOffset + (Math.random() > 0.5 ? 1000 : -1000); // Send away
            }
        }

        function winGame() {
            isGameOver = true;
            document.getElementById('winScreen').classList.add('active');
        }

        function showFeedback(text, isGood) {
            const el = document.getElementById('feedback');
            el.innerText = text;
            el.className = 'feedback-overlay ' + (isGood ? 'feedback-success' : 'feedback-fail');
            el.style.opacity = 1;
            setTimeout(() => el.style.opacity = 0, 1000);
        }

        // --- DRAW ---
        function draw() {
            ctx.clearRect(0, 0, width, height);

            // Draw Belt
            // Belt is part of background image now
            // ctx.fillStyle = '#3e2723';
            // ctx.fillRect(0, beltY + 30, width, 150); 

            // Draw Items (Back to Front for depth? Line is flat)
            items.forEach(item => {
                if (item.picked) return; // Don't draw on belt if picked
                const sx = width / 2 + item.x + beltOffset;
                if (sx < -100 || sx > width + 100) return;

                drawSpriteItem(ctx, item, sx, beltY);
            });

            // Draw Claw
            drawClaw(ctx);
        }

        function drawSpriteItem(c, item, x, y) {
            const key = item.isToy ? TOY_KEYS[item.idx] : TOOL_KEYS[item.idx];
            const img = images[key];
            if (!img) return;

            // Size on screen
            const size = 90;

            c.drawImage(img, 0, 0, img.width, img.height, x - size / 2, y - size, size, size);
        }

        function drawClaw(c) {
            const img = images['CLAW'];
            if (!img) return;

            c.save();
            c.translate(claw.x, claw.y);

            // Draw Held Item
            if (claw.holding) {
                // Modified offset to -50 for better overlap (was 20)
                drawSpriteItem(c, claw.holding, 0, -50);
            }

            // Draw Claw Image (Assumed bottom-centered pivot)
            // Sprite is 1024x1024? No, claw.png is whatever user uploaded.
            // Assuming it's the "Bottom Fixed" one which has the claw at the bottom.
            // Actually, wait, user uploaded a new image. 
            // The image `uploaded_image_...` is likely the full claw assembly.
            // If it's the one I see in the preview, it has a long cable.
            // I should draw it so the "Grab" point is near the bottom.

            const aspect = img.width / img.height; // Wait, full image aspect? Not sprite sheet?
            // The uploaded image is treated as a single image in my code above `isSheet: false`.
            // But wait, user said "use the three sprites" in the request?
            // "use the three sprites" - implies sprite sheet logic for claw too?
            // The uploaded image looks like 3 frames side-by-side. 
            // Frame 1: Open, Frame 2: Half, Frame 3: Closed.

            // UPDATE: I need to handle Claw Sprite Sheet!
            // Let's assume 3 frames horizontal.

            const frameW = img.width / 3;
            const frameH = img.height;

            // State Mapping
            // Open = 0, Closed = 2.
            let frameIdx = (claw.state === 'DOWN' || claw.state === 'IDLE') ? 0 : 2;
            if (claw.state === 'GRAB_WAIT') frameIdx = 1; // Transition?

            const drawH = 780; // Long cable
            const drawW = drawH * (frameW / frameH);

            c.drawImage(img,
                frameIdx * frameW, 0, frameW, frameH,
                -drawW / 2, -drawH + 65, drawW, drawH // Anchor at bottom (grab point)
            );

            c.restore();
        }

        function loop() {
            update();
            draw();
            requestAnimationFrame(loop);
        }

        function toggleMusic() {
            const m = document.getElementById('bgMusic');
            if (m.paused) { m.play(); document.querySelector('.music-toggle').innerText = "MUSIC: ON"; }
            else { m.pause(); document.querySelector('.music-toggle').innerText = "MUSIC: OFF"; }
        }

        // Start
        preloadAssets();

    </script>
</body>

</html>